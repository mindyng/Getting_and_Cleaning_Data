install.packages("swirl")
library("swirl")
swirl()
library("swirl")
> swirl()
swirl()
library(datasets)
data(iris)
?iris
colmeans(iris)
?cat
?iris
tapply(iris, Sepal.Length, Species, mean)
iris()
print iris
print (iris)
tapply(iris, Sepal.Length, Species, mean)
trackeback
traceback
tapply(iris, Sepal.Length,Species, mean)
print(mtcars)
makeCacheMatrix <- function(x = matrix()) {
m<- NULL
set <- function (y) {
x <<- y
m<<- NULL
}
get <- function () x
setmatrix <- function(solve) m <<- solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
makeCacheMatrix <- function(x = matrix()) {
m<- NULL
set <- function (y) {
x <<- y
m<<- NULL
}
get <- function () x
setmatrix <- function(solve) m <<- solve
getmatrix <- function() m
list(set = set, get = get,
setmatrix = setmatrix,
getmatrix = getmatrix)
}
makecacheMatrix(matrix(1:4,2,2))
makeCacheMatrix(matrix(1:4,2,2))
cacheSolve <- function(x, ...) {
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
matrix <- x$get()
m <- solve(matrix, ...)
x$getmatrix(m)
m
}
cacheSolve(solve(x))
solve(matrix)
cacheSolve(1:4,2,2)
cacheSolve(makeCacheMatrix(2*diag(3)))
cacheSolve(x)
cacheSolve(m)
cacheSolve(y)
cacheSolve <- function(x=matrix(),...) {
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
matrix <- x$get()
m <- solve(matrix, ...)
x$getmatrix(m)
m
}
cacheSolve(matrix(1:4,2,2))
cacheSolve <- function(x,...) {
m <- x$getmatrix()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
matrix <- x$get()
m <- solve(matrix, ...)
x$getmatrix(m)
m
}
cacheSolve(matrix(1:4,2,2))
makeCacheMatrix <- function(x = matrix()) {
inv<- NULL
set <- function (y) {
x <<- y
inv<<- NULL
}
get <- function () x
setinverse <- function(inverse) inv <<- inverse
getmatrix <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
makeCacheMatrix <- function(x = matrix()) {
inv<- NULL
set <- function (y) {
x <<- y
inv<<- NULL
}
get <- function () x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
##THIS FUNCTION COMPUTES THE INVERSE OF THE SPECIAL "MATRIX" RETURNED BY
##makeCacheMatrix. IF THE INVERSE HAS ALREADY BEEN CALCULATED AND THE MATRIX
##HAS NOT BEEN CHANGED, THEN THE cachesolve SHOULD RETRIEVE THE INVERSE FROM
##THE CACHE.
##This function computes and outputs the inverse of a matrix.
##First, inverse of a matrix already computed?
##Second, if the inverse of a matrix already exists, there is no computation. Straight output follows.
##Third, if the inverse of a matrix does not exist, then the inverse is computed and stored in cache.
##Fourth, the newly calculated inverse matrix is returned.
## Return a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
makeCacheMatrix <- function(x = matrix()) {
inv<- NULL
set <- function (y) {
x <<- y
inv<<- NULL
}
get <- function () x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
##THIS FUNCTION COMPUTES THE INVERSE OF THE SPECIAL "MATRIX" RETURNED BY
##makeCacheMatrix. IF THE INVERSE HAS ALREADY BEEN CALCULATED AND THE MATRIX
##HAS NOT BEEN CHANGED, THEN THE cachesolve SHOULD RETRIEVE THE INVERSE FROM
##THE CACHE.
##This function computes and outputs the inverse of a matrix.
##First, inverse of a matrix already computed?
##Second, if the inverse of a matrix already exists, there is no computation. Straight output follows.
##Third, if the inverse of a matrix does not exist, then the inverse is computed and stored in cache.
##Fourth, the newly calculated inverse matrix is returned.
## Return a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x = rbind(c(1,2), c(3,4))
m =makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
makeCacheMatrix <- function(x = matrix()) {
im<- NULL
set <- function (y) {
x <<- y
im<<- NULL
}
get <- function () x
setinverse <- function(inverse) im <<- inverse
getinverse <- function() im
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
##THIS FUNCTION COMPUTES THE INVERSE OF THE SPECIAL "MATRIX" RETURNED BY
##makeCacheMatrix. IF THE INVERSE HAS ALREADY BEEN CALCULATED AND THE MATRIX
##HAS NOT BEEN CHANGED, THEN THE cachesolve SHOULD RETRIEVE THE INVERSE FROM
##THE CACHE.
##This function computes and outputs the inverse of a matrix.
##First, inverse of a matrix already computed?
##Second, if the inverse of a matrix already exists, there is no computation. Straight output follows.
##Third, if the inverse of a matrix does not exist, then the inverse is computed and stored in cache.
##Fourth, the newly calculated inverse matrix is returned.
## Return a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
im <- x$getinverse()
if(!is.null(im)) {
message("getting cached data")
return(im)
}
data <- x$get()
im <- solve(data)
x$setinverse(im)
im
}
x = rbind(c(1,2), c(3,4))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
outcome<-read.csv("outcome-of-care-measures.csv", colClasses="character"
source('~/Desktop/R Programming/rprog-data-ProgAssignment3-data/rankall.R')
?rm.na
?is.na
?stop
?min
?unique
?switch
?col
?dat
?switch
best("MD", "pneumonia")
best <- function(state, outcome) {
##Read outcome data
outcome <- read.csv("outcome-of-care-measures.csv",
colClasses = "character")
##Check that state and outcome are valid
if (!state %in% unique(outcome[, 7])) {
stop("invalid state")
}
switch(outcome, `heart attack`= {
col=11
},  `heart failure` = {
col=17
},  pneumonia = {
col=23
}, stop("invalid outcome"))
##Return hospital name in that state with lowest 30-day death
##rate
df = outcome[outcome$State == state, c(2, col)]
df[which.min(df[, 2], 1)]
}
best("MD", "pneumonia")
?col
?order()
rm(list=ls())
7/4
4/7
5/2
?std
library(swirl)
swirl()
telegram <- function(...){
paste("START", ... , "STOP")
}
info()
skip()
exit()
rm(list = ls())
library(swirl)
swirl()
submit()
mad_libs("New York", "angry", "statue")
submit()
submit()
submit()
submit()
'I' %p% 'love' %p% 'R!'
library(swirl)
swirl()
head(flags)
dim(flags)
viewinfo()
class(flags)
?points
library(recommendar)
library(recommenderlab)
rm(list=ls())
swirl()
library(swirl)
swirl()
?grep
?factor
setwd("~/Desktop/Exploratory Data Analysis/Course Project 2/data")
total.emissions <- with(NEI, aggregate(Emissions, by = list(year), sum))
NEI <- readRDS("summarySCC_PM25.rds")
SCC <- readRDS("Source_Classification_Code.rds")
total.emissions <- with(NEI, aggregate(Emissions, by = list(year), sum))
plot(total.emissions, type = "b", pch = 18, col = "red", ylab = "Emissions",
xlab = "Year", main = "Annual Emissions")
#Aggregate Emissions per year.
TotalEmissions <- with(NEI, aggregate(Emissions, by = list(year), sum))
plot(TotalEmissions, type = "b", pch = 18, col = "red", ylab = "Emissions",
xlab = "Year", main = "Total Emissions")
plot(TotalEmissions, type = "b", pch = 18, col = "red", ylab = "Emissions",
xlab = "Year", main = "Total Emissions for US")
NEI.24510 <- NEI[which(NEI$fips == "24510"), ]
TotalEmissionsBaltimore <- with(NEI.24510, aggregate(Emissions, by = list(year), sum))
colnames(TotalEmissionsBaltimore) <- c("year", "Emissions")
plot(TotalEmissionsBaltimore$year, TotalEmissionsBaltimore$Emissions, type = "b",
pch = 18, col = "red", ylab = "Emissions", xlab = "Year", main = "Total Emissions for Baltimore")
NEI.24510 <- NEI[which(NEI$fips == "24510"), ]
TotalEmissionsBaltimore <- with(NEI.24510, aggregate(Emissions, by = list(year), sum))
colnames(TotalEmissionsBaltimore) <- c("year", "Emissions")
#Combine Emissions by year, county(fips == "24510").
TotalEmissionsBaltimoretype <- ddply(NEI.24510, .(type, year), summarize,
Emissions = sum(Emissions))
TotalEmissionsBaltimoretype$Pollutant_Type <- TotalEmissionsBaltimoretype$type
library(plyr)
library(ggplot2)
NEI.24510 <- NEI[which(NEI$fips == "24510"), ]
TotalEmissionsBaltimore <- with(NEI.24510, aggregate(Emissions, by = list(year), sum))
colnames(TotalEmissionsBaltimore) <- c("year", "Emissions")
#Combine Emissions by year, county(fips == "24510").
TotalEmissionsBaltimoretype <- ddply(NEI.24510, .(type, year), summarize,
Emissions = sum(Emissions))
TotalEmissionsBaltimoretype$Pollutant_Type <- TotalEmissionsBaltimoretype$type
qplot(year, Emissions, data = TotalEmissionsBaltimoretype, group = Pollutant_Type,
color = Pollutant_Type, geom = c("point", "line"), ylab = expression("Emissions"),
xlab = "Year", main = "Total Emissions in Baltimore, Maryland by Type of Pollutant")
library(data.table)
NEIDT = data.table(NEI)
SCCDT = data.table(SCC)
CoalSCC = SCCDT[grep("Coal", SCC.Level.Three), SCC]
CoalEmissions = NEIDT[SCC %in% CoalSCC, sum(Emissions), by = "year"]
colnames(CoalEmissions) <- c("year", "Emissions")
g = ggplot(CoalEmissions, aes(year, Emissions))
g + geom_point(color = "blue") + geom_line(color = "red") + labs(x = "Year") +
labs(y = expression("Total Emissions")) + labs(title = "Emissions from Coal Combustion for the US")
MotorVehicleSCC = SCCDT[grep("[Mm]obile|[Vv]ehicles", EI.Sector), SCC]
MotorVehicleEmissionsBaltimore = NEIDT[SCC %in% MotorVehicleSCC, sum(Emissions),
by = c("year", "fips")][fips == "24510"]
colnames(MotorVehicleEmissionsBaltimore) <- c("year", "fips", "Emissions")
g = ggplot(MotorVehicleEmissionsBaltimore, aes(year, Emissions))
g + geom_point(color = "blue") + geom_line(color = "red") + labs(x = "Year") +
labs(y = expression("Total Emissions")) + labs(title = "Total Emissions from Motor Vehicle Sources in Baltimore City")
NEI$year <- factor(NEI$year, levels = c('1999', '2002', '2005', '2008'))
MDOnRoad <- subset(NEI, fips == '24510' & type == 'ON-ROAD')
CAOnRoad <- subset(NEI, fips == '06037' & type == 'ON-ROAD')
MDDF <- aggregate(MDOnRoad[, 'Emissions'], by = list(MDOnRoad$year), sum)
colnames(MDDF) <- c('year', 'Emissions')
MDDF$City <- paste(rep('MD', 4))
CADF <- aggregate(CAOnRoad[, 'Emissions'], by = list(CAOnRoad$year), sum)
colnames(CADF) <- c('year', 'Emissions')
CADF$City <- paste(rep('CA', 4))
DF <- as.data.frame(rbind(MDDF, CADF))
ggplot(data = DF, aes(x = year, y = Emissions)) + geom_bar(aes(fill = year),stat = "identity") + guides(fill = F) + ggtitle('Total Emissions of Motor Vehicle Sources in Los Angeles County, California vs. Baltimore City, Maryland') + ylab(expression('Emissions')) + xlab('Year') + theme(legend.position = 'none') + facet_grid(. ~ City) + geom_text(aes(label = round(Emissions, 0), size = 1, hjust = 0.5, vjust = -1))
rm(list=ls())
setwd("~/Desktop/GettingandCleaningData_CourseProject")
